///////////////////////////////////////////////////////////////////////////
// quest - Textcmd Liste aller Quests (offen/abgeschlossen)
//         Bei collectitem Questitemerstellung
//
// Author: Turley

// Zusatzparameter fuer Staff:
// fremde Questliste einsehen/bearbeiten
Const P_REMOTE    := "remote";

// Assistent fuer Questheiler
Const P_HEAL      := "heal";

// Einrichtung einer Questzone beginnen
Const P_ZONEBEGIN := "zone";

// Einrichtung einer Questzone abschließen
Const P_ZONEEND   := "zonedone";

// Default-Lebenszeit einer Questzone
// (Default-Optionen siehe Funktion QuestZoneConfigGump, Array defopts)
Const DEF_LIFE := 24;

use cfgfile;
use os;
use uo;
include ":death:seppel";
include ":questsystem:questsystem";
include "include/itemnpc";
include "include/modifyskill";
include "include/msgs";
include "include/objtype";
include "include/quests";

var remote := 0;

Program Quest(char, param) // {{{
  If (
    // Questchar oder Staff
    (char.cmdlevel >= CMDLEVEL_QUESTCHAR) and
    // und bestimmter Parameter
    param in (array{P_HEAL, P_ZONEBEGIN, P_ZONEEND})
  )
    QuestSpecialCmd(char, param);
    return;
  EndIf

  // Fremdchar-Auswahl {{{
  var who;
  If ((char.cmdlevel >= CMDLEVEL_HIGHGM) && (param == P_REMOTE))
    SendSysMessagePergon(char,
        "Von welcher Person sollen die Quests angezeigt werden?"
    );
    who := target(char);
    If (who)
      If ((who.isA(POLCLASS_MOBILE)) && (!who.isA(POLCLASS_NPC)))
        remote := 1;
      Else
        SendSysMessagePergon(char, "Abbruch", "Abort");
        return;
      EndIf
    Else
      SendSysMessagePergon(char, "Abbruch", "Abort");
    EndIf
  Else
    who := char;
  EndIf // }}}

  // Menue-Gump {{{
  var ret, prop, cfg, i := 0, qcfg, color;
  var comparray := {}, openarray := {},carray := "<basefont color=#48>",oarray := "",choice, htmltext,text := "";
  var layout := {"nodispose",
               "page 0",
               "resizepic 0 0 9270 390 420",       //Hintergrund links
               "gumppictiled 0 395 108 31 10462",  // unten links
               "gumppic 108 395 10452",            // mitte
               "gumppictiled 286 395 108 31 10462",// unten rechts
               "gumppictiled 0 17 31 378 10464",   // linke seite
               "gumppic 0 0 10301",                // oben links
               "gumppictiled 17 0 362 17 10251",   // mitte oben
               "gumppic 377 0 10303",              // oben rechts
               "gumppictiled 363 17 31 378 10464", // rechte seite
               "htmlgump 48 20 300 30 0 0 0",      // Überschrift
               "resizepic 400 0 9270 390 420",     //Hintergrund rechts
               "gumppictiled 400 395 108 31 10462",// unten links
               "gumppic 508 395 10452",            // mitte
               "gumppictiled 686 395 108 31 10462",// unten rechts
               "gumppictiled 400 17 31 378 10464", // linke seite
               "gumppic 400 0 10301",              // oben links
               "gumppictiled 417 0 366 17 10251",  // mitte oben
               "gumppic 777 0 10303",              // oben rechts
               "gumppictiled 763 17 31 378 10464", // rechte seite
               "htmlgump 448 20 300 30 1 0 0",
               "page 1"};
  var data := {"<basefont color=#FFFFFF size=5><center>Offene Quests</center>",
             "<basefont color=#FFFFFF size=5><center>Abgeschlossene Quests</center>"};


  prop := who.getprop("quest");
  If (!prop)
    If (remote)
      SendSysMessagePergon(char,who.name+" hat noch keine Quests gemacht.");
    Else
      SendSysMessagePergon(who,"Ihr habt bis jetzt noch keine Quests gemacht.");
    EndIf
    return;
  EndIf
  cfg := ReadConfigFile(":questsystem:questtext");
  qcfg := ReadConfigFile(":questsystem:quests");

  ForEach key in (prop.keys())
    If (key!="timeout")
      If (key == "completedquests")
        ForEach k in (prop[key])
          If (cfg[CStr(k)])
            comparray.append({k,cfg[CStr(k)].title});
            If (char.cmdlevel >= CMDLEVEL_HIGHGM)
              carray += +" "+CStr(comparray.size())+" ["+k+"] "+cfg[CStr(k)].title+"<br>";
            Else
              carray += " "+CStr(comparray.size())+" "+cfg[CStr(k)].title+"<br>";
            EndIf
          Else
            syslog("Fehlerhafte Quest "+CStr(k)+" bei "+who.serial);
          EndIf
        EndForEach
      Else
        If (cfg[CStr(key)])
          openarray.append({key,cfg[CStr(key)].title});
          color := SearchItems(who,qcfg[CStr(key)], key);
          If (char.cmdlevel >= CMDLEVEL_HIGHGM)
            oarray += " <basefont color="+color+">"+CStr(openarray.size())+" ["+key+"] "+cfg[CStr(key)].title+"<br>";
          Else
            oarray += " <basefont color="+color+">"+CStr(openarray.size())+" "+cfg[CStr(key)].title+"<br>";
          EndIf
        Else
          syslog("Fehlerhafte Quest "+CStr(key)+" bei "+who.serial);
        EndIf
      EndIf
    EndIf
  EndForEach

  layout.append("htmlgump 48 50 300 300 "+data.size()+" 1 1");   // Offene Questliste
  data.append(oarray);
  layout.append("htmlgump 448 50 300 300 "+data.size()+" 1 1");  // Abgeschlossene Questsliste
  data.append(carray);
  layout.append("text 50 360 910 "+data.size());
  data.append("Beschreibung");
  layout.append("gumppic 150 360 2444");
  layout.append("textentry 165 362 30 20 0 4 "+data.size()); //Nr eintragen (Offene Quests)
  data.append("1");
  layout.append("button 220 357 9721 9724 1 0 1");  // Ok button
  layout.append("text 450 360 910 "+data.size());
  data.append("Beschreibung");
  layout.append("gumppic 550 360 2444");
  layout.append("textentry 565 362 30 20 0 5 "+data.size()); //Nr eintragen (Abgeschlossene Quests)
  data.append("1");
  layout.append("button 620 357 9721 9724 1 0 2");  // Ok button

  If (char.cmdlevel>=CMDLEVEL_HIGHGM)
    layout.append("button 720 357 9721 9724 1 0 3");
    layout.append("text 670 360 37 "+data.size());
    data.append("Aendern");
  EndIf
  If (remote)
    ret := SendDialogGump(char,layout,data,50,50);
  Else
    ret := SendDialogGump(who,layout,data,50,50);
  EndIf
  layout := {"nodispose",
           "page 0",
           "resizepic 0 0 9270 390 420",       //Hintergrund links
           "gumppictiled 0 395 108 31 10462",  // unten links
           "gumppic 108 395 10452",            // mitte
           "gumppictiled 286 395 108 31 10462",// unten rechts
           "gumppictiled 0 17 31 378 10464",   // linke seite
           "gumppic 0 0 10301",                // oben links
           "gumppictiled 17 0 362 17 10251",   // mitte oben
           "gumppic 377 0 10303",              // oben rechts
           "gumppictiled 363 17 31 378 10464", // rechte seite
           "htmlgump 48 20 300 30 0 0 0",      // Überschrift
           "htmlgump 48 50 300 300 1 1 1"};    // Beschreibung

  Case (ret.keys[2])
    1:  // Offene Quests
        choice := ret[4];
        choice[1,3] := "";
          If (!openarray[CInt(choice)])
            If (remote)
              SendSysMessagePergon(char,"Ungültige Wahl.");
            Else
              SendSysMessagePergon(who,"Ungültige Wahl.");
            EndIf
          return;
        EndIf
        data := {"<basefont color=#FFFFFF size=5><center>"+cfg[openarray[CInt(choice)][1]].title+"</center>"};
        htmltext := GetConfigStringArray(cfg[openarray[CInt(choice)][1]], "text");

        For (i := 1;i<=htmltext.size();i += 1)
          If (text[Len(text)-2,Len(text)] == "<p>") // Html Cmd am Ende dann kein Leerzeichen (<p>)
            text += htmltext[i];
          Else
            text += " "+htmltext[i];
          EndIf
        EndFor
        If (text[1] == " ")
          text[1] := "";
        EndIf
        data.append(text);
        layout.append("button 50 357 9721 9724 1 0 2");
        layout.append("text 85 360 910 2");
        data.append("Quest Abbrechen");
        If (qcfg[openarray[CInt(choice)][1]].type == "collectitem")
          layout.append("text 255 360 910 "+data.size());
          data.append("Quest Item");
          layout.append("button 220 357 9721 9724 1 0 1");
        EndIf

        If (remote)
          ret := SendDialogGump(char,layout,data,50,50);
        Else
          ret := SendDialogGump(who,layout,data,50,50);
        EndIf
        If (ret.keys[2] == 1)
          SetQuestItem(who,choice,openarray,char);
        ElseIf (ret.keys[2] == 2)
          QuestAbbruch(who,openarray[CInt(choice)][1],0,openarray[CInt(choice)][2],char,remote);
        EndIf

    2:  // Abgeschlossene Quests
        choice := ret[5];
        choice[1,3] := "";
          If (!comparray[CInt(choice)])
            If (remote)
              SendSysMessagePergon(char,"Ungültige Wahl.");
            Else
              SendSysMessagePergon(who,"Ungültige Wahl.");
            EndIf
            return;
          EndIf
        data := {"<basefont color=#FFFFFF size=5><center>"+cfg[comparray[CInt(choice)][1]].title+"</center>"};
        htmltext := GetConfigStringArray(cfg[comparray[CInt(choice)][1]], "text");

        For (i := 1;i<=htmltext.size();i += 1)
          If (text[Len(text)-2,Len(text)] == "<p>") // Html Cmd am Ende dann kein Leerzeichen (<p>)
            text += htmltext[i];
          Else
            text += " "+htmltext[i];
          EndIf
        EndFor
        If (text[1] == " ")
          text[1] := "";
        EndIf
        data.append(text);

        If (remote)
          SendDialogGump(char,layout,data,50,50);
        Else
          SendDialogGump(who,layout,data,50,50);
        EndIf
     3: QuestAendern(who,char,qcfg);
    default: return;
  EndCase // }}}
EndProgram // }}}

// Zusatzkommandos fuer Quest (fuer >= Questchar gedacht)
Function QuestSpecialCmd(who, param) // {{{
  Case (param)
  P_HEAL: // Heilertore und Heiler aufbauen {{{
    var pos, gate;
    SendSysMessagePergon(who, "Ort für Heilertor wählen!"); // {{{
    GATELOOP: While (1 == 1)
      pos := TargetCoordinates(who);
      If (!pos or pos.item.container)
        SendSysMessagePergon(who, "Abbruch", "Abort");
        break GATELOOP;
      EndIf
      gate := CreateItemAtLocation(
        pos.x, pos.y, pos.z, "questgateoflife", 1, pos.realm
      );
      If (gate)
        // Tor sofort wieder verfuegbar
        gate.setprop("regen_seconds", 1);
        gate.setprop(PROP_QUESTBUILT, who.serial);
        // Logging
        QuestCharLog(who, " baut "+ItemInfoStr(gate, COORDS_REALM));
      Else
        SendSysMessagePergon(who, "Fehler: "+gate.errortext);
      EndIf
    EndWhile
    // }}}

    SendSysMessagePergon(who, "Ort für Seppelgate wählen!"); // {{{
    SEPPELLOOP: While (1 == 1)
      pos := TargetCoordinates(who);
      If (!pos or pos.item.container)
        SendSysMessagePergon(who, "Abbruch", "Abort");
        break SEPPELLOOP;
      EndIf
      gate := CreateItemAtLocation(
        pos.x, pos.y, pos.z, "seppelgate", 1, pos.realm
      );
      If (gate)
        // fuer alle erlauben
        gate.setprop(ALLOW_NEWBIE, 1);
        // niedrige Kosten setzen
        gate.setprop(SG_FACT_PLUS, 0.02);
        gate.setprop(SG_FACT_RES, 0.01);
        gate.setprop(SG_FACT_WAIT, 0.2);
        gate.setprop(PROP_QUESTBUILT, who.serial);
        // Logging
        QuestCharLog(who, " baut "+ItemInfoStr(gate, COORDS_REALM));
      Else
        SendSysMessagePergon(who, "Fehler: "+gate.errortext);
      EndIf
    EndWhile
    // }}}

    SendSysMessagePergon(who, "Ort fuer Questheiler waehlen!"); // {{{
    HEALLOOP: While (1 == 1)
      pos := TargetCoordinates(who);
      If (!pos or pos.item.container)
        SendSysMessagePergon(who, "Abbruch", "Abort");
        break HEALLOOP;
      EndIf
      var healer := CreateNpcFromTemplatePergon(
        "questhealerm", pos.x, pos.y, pos.z, 0, 0, 0, pos.realm
      );
      If (healer)
        healer.setprop(PROP_QUESTBUILT, who.serial);
        // Logging
        QuestCharLog(who, " stellt "+CharInfoStr(gate, COORDS_REALM)+" auf");
      Else
        SendSysMessagePergon(who, "Fehler: "+healer.errortext);
      EndIf
      SendSysMessagePergon(who,
        "Ort für weiteren Heiler wählen oder abbrechen!"
      );
    EndWhile
    // }}}

    SendSysMessagePergon(who, "Fertig");
    return;
    // }}}

  P_ZONEBEGIN: // ersten Eckpunkt merken {{{
    var pos1 := struct;
    pos1.x     := who.x;
    pos1.y     := who.y;
    pos1.realm := who.realm;
    who.setprop(PROP_ZONEMAKE, pos1);
    SendSysMessagePergon(who,
      "Startposition für Questzone gemerkt. Weiter mit '.quest "+
      P_ZONEEND+"'."
    );
    return;
    // }}}

  P_ZONEEND: // zweiter Eckpunkt, Einstellungen abfragen {{{
    var pos1 := who.getprop(PROP_ZONEMAKE);
    If (!pos1)
      SendSysMessagePergon(who,
        "Keine Startposition mit '.quest '"+P_ZONEBEGIN+"' markiert! "+
        "(geht beim Ausloggen verloren)"
      );
      return;
    EndIf

    var pos2 := struct;
    pos2.x     := who.x;
    pos2.y     := who.y;
    pos2.realm := who.realm;
    SendSysMessagePergon(who, "Zweiter Eckpunkt gemerkt");

    // Optionsgump aufrufen
    var config := QuestZoneConfigGump(who, pos1, pos2);
    If (!config)
      SendSysMessagePergon(who, "Abbruch", "Abort");
      return;
    EndIf

    var res;
    For i := 1 To 10
      res := QuestZoneAdd(pos1, pos2, config.opts, config.lifetime);
      If (res)
        break;
      EndIf
      If (!res and res.errortext == QZ_ERR_NOLOCK)
        SendSysMessagePergon(who,
          "Bitte warten, Questzonen werden gerade bearbeitet"
        );
      EndIf
      Sleep(6);
    EndFor

    If (!res)
      SendSysMessagePergon(who, "Wartezeit überschritten, Abbruch");
      return;
    EndIf

    SendSysMessagePergon(who, "Neue Questzone eingerichtet");
    return;
    // }}}
  EndCase
EndFunction // }}}

// Hilfsfunktion fuer Itembeschaffungsquests
Function SetQuestItem(who, choice, openarray, char) // {{{
  var tar, prop, pro, i, j := 0, item, anz := 0, items := {}, temp := {}, name := "";

  If (remote)
    SendSysMessagePergon(char,"Wählt den Gegenstand aus, der für dieses Quest genutzt werden soll.");
    tar := Target(char);
    If (!tar)
      SendSysMessagePergon(char,"Abbruch", "Abort");
      return (0);
    EndIf
  Else
    SendSysMessagePergon(who,"Wählt den Gegenstand aus, der fuer dieses Quest genutzt werden soll.");
    tar := Target(who);
    If (!tar)
      SendSysMessagePergon(who,"Abbruch", "Abort");
      return (0);
    EndIf
  EndIf
  prop := who.getprop("quest");
  pro := prop[openarray[CInt(choice)][1]];
  For (i := 1;i<=pro[2].size();i += 1)  // Alle Items durchgehen
    If (pro[2][i][1] == tar.objtype)
      anz := tar.amount;
      items.append(tar);
      ForEach item in (EnumerateItemsInContainer(who.backpack))  // Wieviel Questitems existieren denn schon?
        If (item.objtype == QUEST_DUMMY)
          If (item.getprop("obj") == pro[2][i][1])
            j := 1;
            Break;
          EndIf
        ElseIf ((item.objtype == tar.objtype) && (item.serial<>tar.serial))
          If (anz<pro[2][i][2])  // Schon Genug?
            anz += item.amount;
            items.append(item);
          EndIf
        EndIf
      EndForEach

      If (j == 1)
        If (remote)
          SendSysMessagePergon(char,"Ihr besitzt schon genug.");
        Else
          SendSysMessagePergon(who,"Ihr besitzt schon genug.");
        EndIf
        return (0);
      ElseIf (anz>=pro[2][i][2])
        item := CreateItemInBackpackPergon(who, QUEST_DUMMY, 1, 0);  // DummyQuestItem
        item.graphic := tar.graphic;
        temp := SplitWords(tar.desc);
        If (CInt(temp[1])>0)  // Stackzahl loswerden
          For (j := 2;j<=temp.size();j += 1)
            name += " "+temp[j];
          EndFor
          name[1,1] := "";
        Else
          If (pro[2][i][2]>1)
            name := DescMehrzahl(tar.desc);
          Else
            name := DescEinzahl(tar.desc);
          EndIf
        EndIf
        If (pro[2][i][2]>1)
          item.name := "Ein paar "+name;
        Else
          item.name := name;
        EndIf
        item.setprop("obj",tar.objtype);
        anz := 0;
        ForEach itemtar in (items)
          If (anz+itemtar.amount<pro[2][i][2])
            anz += itemtar.amount;
            If (!SubtractAmount(itemtar,itemtar.amount))
              DestroyItem(item);
              If (remote)
                SendSysMessagePergon(char,"Irgendetwas ist schief gegangen.");
              Else
                SendSysMessagePergon(who,"Irgendetwas ist schief gegangen.");
              EndIf
              return(0);
            EndIf
            If (anz == pro[2][i][2])
              Break;
            EndIf
          Else
            If (!SubtractAmount(itemtar,pro[2][i][2]-anz))
              DestroyItem(item);
              If (remote)
                SendSysMessagePergon(char,"Irgendetwas ist schief gegangen.");
              Else
                SendSysMessagePergon(who,"Irgendetwas ist schief gegangen.");
              EndIf
              return(0);
            EndIf
            Break;
          EndIf
        EndForEach
        If (remote)
          SendSysMessagePergon(char,"Ihr besitzt nun "+name+".");
          PlaySoundEffectPrivate(char,SFX_5B7,char);
        Else
          SendSysMessagePergon(who,"Ihr besitzt nun "+name+".");
          PlaySoundEffectPrivate(who,SFX_5B7,who);
        EndIf
        return(0);
      Else
        If (remote)
          SendSysMessagePergon(char,"Ihr besitzt noch nicht genug.");
        Else
          SendSysMessagePergon(who,"Ihr besitzt noch nicht genug.");
        EndIf
        return(0);
      EndIf
    EndIf
  EndFor
  If (remote)
    SendSysMessagePergon(char,"Was wollt Ihr denn damit anfangen?");
  Else
    SendSysMessagePergon(who,"Was wollt Ihr denn damit anfangen?");
  EndIf
EndFunction // }}}

Function QuestAendern(who, char, qcfg) // {{{
  var cprop,i,done := 0;
  var layout := {"nodispose",
               "page 0",
               "resizepic 0 0 9270 390 200",       //Hintergrund links
               "gumppictiled 0 179 108 31 10462",  // unten links
               "gumppic 108 179 10452",            // mitte
               "gumppictiled 286 179 108 31 10462",// unten rechts
               "gumppictiled 0 17 31 162 10464",   // linke seite
               "gumppic 0 0 10301",                // oben links
               "gumppictiled 17 0 362 17 10251",   // mitte oben
               "gumppic 377 0 10303",              // oben rechts
               "gumppictiled 363 17 31 162 10464", // rechte seite
               "htmlgump 48 30 300 60 0 0 0",      // Text
               "gumppic 82 98 2444",
               "textentry 97 100 30 20 0 3 1", //Nr eintragen (Abgeschlossene Quests)
               "Button 217 76 9721 9724 1 0 1",    // Hinzufuegen
               "text 250 80 910 2",
               "Button 217 116 9721 9724 1 0 2",  // Loeschen
               "text 250 120 910 3"};
  var data := {"<basefont color=#FFFFFF><center>Completed Quests hinzufuegen/loeschen",
             "",
             "Hinzufuegen",
             "Loeschen"};
  var ret := SendDialogGump(char,layout,data,50,50);
  var choice := ret.keys[2];
  var number := ret[3];
  number[1,3] := "";
  number := CInt(number);
  If (!qcfg[CStr(number)])
    If (remote)
      SendSysMessagePergon(char,"Ungültige QuestNr!");
    Else
      SendSysMessagePergon(who,"Ungültige QuestNr!");
    EndIf
    return;
  EndIf

  cprop := who.getprop("quest");

  Case (choice)
    1:  If (number in cprop["completedquests"])
          If (remote)
            SendSysMessagePergon(char,"Quest ist bereits abgeschlossen.");
          Else
            SendSysMessagePergon(who,"Quest ist bereits abgeschlossen.");
          EndIf
          return;
        EndIf
        If (!cprop.exists("completedquests"))
          cprop["completedquests"] := {};
        EndIf
        cprop["completedquests"].append(number);
        who.setprop("quest",cprop);
    2:  If (!(number in cprop["completedquests"]))
          If (remote)
            SendSysMessagePergon(char,"Quest ist noch nicht abgeschlossen.");
          Else
            SendSysMessagePergon(who,"Quest ist noch nicht abgeschlossen.");
          EndIf
          return;
        EndIf
        For (i := 1;i<=cprop["completedquests"].size();i += 1)
          If (number == cprop["completedquests"][i])
            cprop["completedquests"].erase(i);
            done := 1;
            Break;
          EndIf
          SleepMS(5);
        EndFor
        If (!done)
          If (remote)
            SendSysMessagePergon(char,"Irgendwas ist schief gelaufen.");
          Else
            SendSysMessagePergon(who,"Irgendwas ist schief gelaufen.");
          EndIf
          return;
        EndIf

        who.setprop("quest",cprop);
        If (remote)
          SendSysMessagePergon(char,"Quest Nr "+number+" erfolgreich gelöscht.");
        Else
          SendSysMessagePergon(who,"Quest Nr "+number+" erfolgreich gelöscht.");
        EndIf
    default: return;
  EndCase
EndFunction // }}}

//////////////////////////////////////
// SearchItems - HtmlColor-Bestimmung
// Komplett = grün
// sonst    = schwarz/rot
//////////////////////////////////////
Function SearchItems(who, cfgelem, key) // {{{
  var items := 0, monster := {};
  Case (cfgelem.type)
    "collectitem":
      ForEach item in (FindSubstance(who.backpack,QUEST_DUMMY,1,0,FINDSUBSTANCE_FIND_ALL))
        ForEach prop in (who.getprop("quest")[CStr(key)][2]) //Welche Objecttypes sind gesucht?
          If (item.getprop("obj") == prop[1])
            items += 1;
            break;
          EndIf
        EndForEach
        SleepMS(2);
      EndForEach
      If (items>=who.getprop("quest")[CStr(key)][2].size()) // Genug gefunden?
        return("#008000"); //Grün
      Else
        return("#800000"); // Rot
      EndIf
    "kill":
      ForEach item in (FindSubstance(who.backpack,QUEST_DUMMY,1,0,FINDSUBSTANCE_FIND_ALL))
        ForEach prop in (who.getprop("quest")[CStr(key)][2]) // Welche Templates?
          If (Lower(item.getprop("template")) == Lower(prop[1]))
            If (monster[_prop_iter]) //Passendes Element im Array erhöhen
              monster[_prop_iter] += 1;
            Else
              monster[_prop_iter] := 1;
            EndIf
          EndIf
        EndForEach
        SleepMS(2);
      EndForEach
      If (monster.size())
        ForEach beweis in (monster)
          If ((who.getprop("quest")[CStr(key)][2][_beweis_iter][2])>beweis) //Nicht genug? Dann gleich abbrechen
            return("#48"); //Schwarz
          Else
            items += 1;
          EndIf
        EndForEach
      Else
        return("#48");
      EndIf
      If (items == who.getprop("quest")[CStr(key)][2].size())
        return("#008000"); //Grün
      Else
        return("#48");
      EndIf

    "npcitem":
      ForEach item in (FindSubstance(who.backpack,QUEST_DUMMY,1,0,FINDSUBSTANCE_FIND_ALL))
        ForEach prop in (who.getprop("quest")[CStr(key)][2]) // Welche Templates?
          If (Lower(item.getprop("npcitemtemplate")) == Lower(prop[1]))
            If (monster[_prop_iter]) //Passendes Element im Array erhöhen
              monster[_prop_iter] += 1;
            Else
              monster[_prop_iter] := 1;
            EndIf
          EndIf
        EndForEach
        SleepMS(2);
      EndForEach
      If (monster.size())
        ForEach beweis in (monster)
          If ((who.getprop("quest")[CStr(key)][2][_beweis_iter][2])>beweis) //Nicht genug? Dann gleich abbrechen
            return("#48"); //Schwarz
          Else
            items += 1;
          EndIf
        EndForEach
      Else
        return("#48");
      EndIf

      If (items == who.getprop("quest")[CStr(key)][2].size())
        return("#008000"); //Grün
      Else
        return("#48");
      EndIf

    default:  //Restliche werden automatisch Beendet wenn erfolgreich
      return("#48");
  EndCase
EndFunction // }}}

// Konfigurationsgump fuer Questzonen
Const BUTT_OK  := 100;
Const FLD_LIFE := 2;
Function QuestZoneConfigGump(who, pos1, pos2) // {{{
  // Standardoptionen fuer Questzone
  var defopts := array{
    QZ_OPT_KILL,
    QZ_OPT_DESTROY,
    QZ_OPT_NOLOOT,
    QZ_OPT_NOCARVE
  };

  var layout := array{ // {{{
    // Hintergrund
    "page 0",
    "nodispose",
    "resizepic 0 0 2620 310 "+(300+112),
    // Balken unter Titel
    "gumppic 20 50 2621",
    "checkertrans 5 6 300 "+(300+100),
    // Ueberschrift
    "text 20 10 40 0",
    "text 20 30 40 1",
    "page 1",
    // "Zonenoptionen"
    "text 20 60 40    2",
    // Aktionen
    "text 60  80 40  3",
    "text 60 120 40  4",
    "text 60 160 40  5",
    "text 60 200 40  6",
    "text 60 240 40  7",
    "text 60 280 40  8",
    "text 60 320 40  9"
  };
  var i;
  var opts := array{
    QZ_OPT_DESTROY, QZ_OPT_KILL,     QZ_OPT_CLEAR,
    QZ_OPT_NOLOOT,  QZ_OPT_NOCORPSE, QZ_OPT_NOCARVE
  };
  opts.sort();
  For (i := 1; i <= 6; i += 1)
    var onoff := 0;
    If (opts[i] in (defopts))
      onoff := 1;
    EndIf
    layout.append(
      "checkbox 20 "+(75+40*i)+" 2152 2154 "+onoff+" "+(1000+opts[i])
    );
  EndFor
  layout += array{
    "resizepic 210 70 2620 80 40",
    "textentry 220 80 70 20 50 "+FLD_LIFE+" 10",
    // Ok-Button
    "button  60 375 2076 2075 1 0 "+BUTT_OK,
    // Cancel-Button
    "button 200 375 2073 2072 1 0 0",
    ""
  }; // }}}

  // Ort(e) fuer 'data' ermittlen und vorbereiten
  var place1 := PlaceName(pos1);
  var place2 := PlaceName(pos2);
  If (place1 <> place2)
    place1 := place1+"'/'"+place2;
  EndIf

  var data := array{ // {{{
    "Questzone ("+pos1.x+", "+pos1.y+") - ("+pos2.x+", "+pos2.y+")",
    "bei '"+place1+"'",
    "Zonenoptionen",
    "Lebensdauer (in Stunden):",
    "Questitems zerstoeren",
    "Quest-NPC toeten",
    "Spieler entfernen",
    "Kein Loot",
    "Keine NPC-Leichen",
    "Kein Haeuten/Schlachten",
    DEF_LIFE
  }; // }}}

  var ret := SendDialogGump(who, layout, data, 100, 20);
  If (CInt(ret[0]) <> BUTT_OK)
    return error{errortext := "Config cancelled"};
  EndIf

  // Rueckgabewerte aufbereiten {{{
  var config := struct;
  config.+lifetime := GetNumericValue(ret[FLD_LIFE]);
  If (config.lifetime < 1)
    config.lifetime := 24;
  EndIf

  var newopts := array{};
  ForEach key in (ret.keys)
    var val := CInt(key) - 1000;
    If (val in (opts))
      newopts.append(val);
    EndIf
  EndForEach
  config.+opts := newopts;
  // }}}

  return config;
EndFunction // }}}

// Gump-Dictwerte in Key und Wert splitten
Function GetNumericValue(retstr) // {{{
    var splitted := SplitWords(retstr, " ");
    return CInt(splitted[2]);
EndFunction // }}}

// vim: sw=2 sts=2
