///////////////////////////////////////////////////////////////////////////
// bboard - Clientseitiges Nachrichtenbrett
//
// Author: Turley

Const NAME_STORAGE_AREA := "Blackboards";
Const NAME_STORAGE_BOX  := "Default";

use os;
use polsys;
use storage;
use uo;
include "include/clock";
include "include/msgs";
include "include/storage";

Program BBoard(params, board)
  Case (params[1])
    3: RequestMessage(params[2], params[3]);
    4: RequestSummary(params[2], params[3]);
    5: PostMessage(params[2], params[3]);
    6: RemoveMessage(params[2], params[3]);
    default:
       Display(params[1], board);
  EndCase
EndProgram

// helper functions
// get message box in storage area
Function GetBox() // {{{
  var area := FindOrCreateStorage(NAME_STORAGE_AREA);
  If (!area)
    return;
  EndIf

  var box := FindOrCreateRootItemInStorage(area, NAME_STORAGE_BOX);
  return box;
EndFunction // }}}

// delete old messages from box
Function MsgsExpire(box) // {{{
  var time := ReadGameClock();

  var last_purge := CInt(box.getprop("last_purge"));
  If (last_purge + 24*60*60 > time)
    // einmal am Tag genuegt
    return;
  EndIf

  var delete := {}, delserial := {};
  // Nach einiger Zeit loeschen
  ForEach msg in (EnumerateItemsInContainer(box))
    If ((CInt(msg.getprop("ct")) + 31 * 24*60*60) <= time)
      delete.append(msg);
      delserial.append(msg.serial);
    EndIf
  EndForEach
  // falls Antworten existieren, noch nicht loeschen
  ForEach msg in (EnumerateItemsInContainer(box))
    If ((msg.getprop("reply") in delserial) && !(msg.serial in delserial))
      var i;
      For (i := 1; i <= delserial.size(); i += 1)
        If (msg.getprop("reply") == delserial[i])
          delserial.erase(i);
          delete.erase(i);
        EndIf
      EndFor
    EndIf
  EndForEach
  ForEach msg in (delete)
    DestroyItem(msg);
  EndForEach
EndFunction // }}}

// main functions
// Nachrichtenuebersicht anzeigen
Function Display(who, board) // {{{
  var box := GetBox();
  If (!box)
    return;
  EndIf

  MsgsExpire(box);

  var packet := CreatePacket(0x71, MSGLEN_VARIABLE);
  packet.setint8(3,   0);             // Sub
  packet.setint32(4,  board.serial);
  packet.setstring(8, board.desc, 0); // Name
  packet.setint32(29, 0);
  packet.setint32(34, 0);
  packet.sendpacket(who);

  var items := EnumerateItemsInContainer(box);
  packet := CreatePacket(0x3c, MSGLEN_VARIABLE);
  packet.setint16(3, items.size()); // wieviel Items
  ForEach item in (items)
    packet.setint32(packet.getsize(), item.serial);  // Serial
    packet.setint16(packet.getsize(), item.graphic); // Grafik
    packet.setint8(packet.getsize(),  1); // falls Stack wieviel auf Graphic
    packet.setint16(packet.getsize(), 1); // Amount
    packet.setint16(packet.getsize(), 0); // X
    packet.setint16(packet.getsize(), 0); // Y
                                          // welcher Container
    packet.setint32(packet.getsize(), board.serial);
    packet.setint16(packet.getsize(), 0); // Hue
  EndForEach
  packet.sendpacket(who);
EndFunction // }}}

// Nachrichtenzusammenfassung fuer Threadansicht
Function MessageSummary(who, board, msgserial) // {{{
  var msg := SystemFindObjectBySerial(msgserial);
  If (!msg)
    return;
  EndIf

  var packet := CreatePacket(0x71, MSGLEN_VARIABLE);
  packet.setint8(3,    1);                    // Sub
  packet.setint32(4,   board);                // Board
  packet.setint32(8,   msg.serial);           // Message-Id
  packet.setint32(12,  msg.getprop("reply")); // Parent
  packet.setint8(16,   len(msg.getprop("author"))+1);
  packet.setstring(17, msg.getprop("author"), 1);
  packet.setint8(packet.getsize(),   len(msg.getprop("title"))+1);
  packet.setstring(packet.getsize(), msg.getprop("title"), 1);
  packet.setint8(packet.getsize(),   len(msg.getprop("time"))+1);
  packet.setstring(packet.getsize(), msg.getprop("time"), 1);
  packet.sendpacket(who);
EndFunction // }}}

// komplette Nachricht anzeigen
Function Message(who, board, msgserial) // {{{
  var msg := SystemFindObjectBySerial(msgserial);
  If (!msg)
    return;
  EndIf

  var packet := CreatePacket(0x71, MSGLEN_VARIABLE);
  packet.setint8(3,    2);          // Sub
  packet.setint32(4,   board);      // Board
  packet.setint32(8,   msg.serial); // Message-Id
  packet.setint8(12,   len(msg.getprop("author"))+1);
  packet.setstring(13, msg.getprop("author"), 1);
  packet.setint8(packet.getsize(),   len(msg.getprop("title"))+1);
  packet.setstring(packet.getsize(), msg.getprop("title"), 1);
  packet.setint8(packet.getsize(),   len(msg.getprop("time"))+1);
  packet.setstring(packet.getsize(), msg.getprop("time"), 1);
  packet.setint16(packet.getsize(),  0); // Body
  packet.setint16(packet.getsize(),  0); // Hue
  packet.setint8(packet.getsize(),   0); // Items
  packet.setint8(packet.getsize(),   msg.getprop("text").size());
  ForEach line in (msg.getprop("text"))
    // FIXME:
    line += "*";
    packet.setint8(packet.getsize(),   len(line)+1);
    packet.setstring(packet.getsize(), line, 1);
  EndForEach
  packet.sendpacket(who);
EndFunction // }}}

Function RequestMessage(who, packet)
  Message(who, packet.getint32(4), packet.getint32(8));
EndFunction

Function RequestSummary(who, packet)
  MessageSummary(who, packet.getint32(4), packet.getint32(8));
EndFunction

// Nachricht zum Board hinzufuegen
Function PostMessage(who, packet) // {{{
  var box := GetBox();
  If (!box)
    return;
  EndIf

  var lines := 13+packet.getint8(12); // Wieviel Zeilen
  var text := {}, j := 1, i;
  For (i := 1; i <= packet.getint8(lines); i += 1) // Text speichern
    text.append(packet.getstring(lines+1+j, packet.getint8(lines+j)-1));
    j += packet.getint8(lines+j)+1;
  EndFor
  var msg := GetItemDescriptor(0xfff1);
  msg.CProps.insert("author", who.name);
  msg.CProps.insert("ct",     ReadGameClock());
  msg.CProps.insert("reply",  packet.getint32(8)); // Replymessage?
  msg.CProps.insert("text",   text);
  If (packet.getint8(12)) // Ist ein Title vorhanden?
    msg.CProps.insert("title", packet.getstring(13, packet.getint8(12)-1));
  Else
    msg.CProps.insert("title", "");
  EndIf
  var date := GetDateTimeStr();
  msg.CProps.insert("time", date[5, 2]+"."+date[2, 2]+" "+date[8, 5]);
  var result := CreateItemInContainer(box, msg, 1);
  If (error == result)
    syslog("FEHLER: Ablegen der Nachricht gescheitert: "+result.errortext);
  EndIf
EndFunction // }}}

// Nachricht entfernen
Function RemoveMessage(who, packet) // {{{
  // Mich würde ja mal interessieren wie das gehen soll
  SysLog(
    "BBoard RemoveRequest: "+who.name+" ("+who.serial+") Packetraw: "+packet
  );
  SendSysMessagePergon(who,
    "Dies wäre ein erfolgreiches Löschen gewesen, unbedingt merken wie "+
    "es geschafft wurde und dem Staff melden!"
  );
EndFunction // }}}

// vim: sw=2 sts=2
