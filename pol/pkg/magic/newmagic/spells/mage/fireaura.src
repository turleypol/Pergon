//**************************************************************************************************
// Script file fireaura.src
//
//    implements spell 119 <Fire Aura> - "Flammenaura"
//
//  caster achieves fire aura which deals fire damage to adjacent mobiles
//  lower resistance against water pushes adjacent mobiles away
//     [ Resisted (Elemental - Fire) ]
//
//  Vers. 0.9 - 19.11.2001 Sebastian 'Bihinos' Giese
//  Vers. 1.1 - 28.06.2003 Sebastian 'Bihinos' Giese - ueberarbeitet
//
//**************************************************************************************************

include "../spellattack";
include "include/spellcheck";

Program cast_fireaura (params)
	
  var caster, victims, resist, dmg, power;
  var spells   := ReadConfigFile("::spells");                   // load spelldata
  var spell    := FindConfigElem(spells, SPELLID_MAGE_FIREAURA);
  var basedmg  := spell.primary;
  var mindmg   := spell.primarymin;
  var maxdmg   := spell.primarymax;
  var chngres  := spell.secondary;
  var minchng  := spell.secondarymin;
  var maxchng  := spell.secondarymax;
  var dur      := spell.duration;
  var mindur   := spell.durationmin;
  var maxdur   := spell.durationmax;
  var range    := spell.range;
  var minrange := spell.rangemin;
  var maxrange := spell.rangemax;

  If (params[1] == "#MOB")
    caster := params[2];
    power  :=  params[3];
  ElseIf (params[1] == "#SCROLL")
    caster := params[2];
    power  :=  params[3];
  Else
    caster := params[1];
    power  := GetCastPowerPergon(caster, SPELLID_MAGE_FIREAURA);
  EndIf

  PerformAction(caster, ANIM_CAST_AREA);

  If (GetObjProperty(caster, "spell_aura"))
	  If (GetObjProperty(caster, "spell_aura")[2] == "fire");   // check If caster already has elemental aura
	    SendSysMessagePergon(caster, "Ihr verfügt bereits ueber eine Flammenaura oder verkraftet zur Zeit keine weitere Aura",
	                                 "You are already protected by a Fire Aura or you are not ready to bear another Aura yet");
	    return;
    Else
    	var tag := GetObjProperty(caster, "spell_aura");
    	tag[5]  := GetPID();
    	SetObjProperty(caster, "spell_aura", tag);
    	SendSpellwaiter(caster, "spell_aura", 0, tag[4], caster);
    	While (1)
    		var ev := Wait_For_Event(200);
    		If (ev)
    			break;
    		EndIf
    	EndWhile
    EndIf
  EndIf

  basedmg := CDbl(power*basedmg/100.0);     // calc duration, range and spell damage according to
  chngres := CInt(power*chngres/100.0);     // casting power
  dur     := CInt(power*dur/100.0);
  range   := CInt(power*range/100.0);

  If (minchng and minchng > chngres)
    chngres := minchng;
  ElseIf (maxchng and maxchng < chngres)
    chngres := maxchng;
  EndIf
  If (mindur and mindur > dur)
    dur := mindur;
  ElseIf (maxdur and maxdur < dur)
    dur := maxdur;
  EndIf
  If (minrange and minrange > range)
    range := minrange;
  ElseIf (maxrange and maxrange < range)
    range := maxrange;
  EndIf

  var tag := array;
  tag[1]  := ReadGameClock() + CInt(dur * 1.5);
  tag[2]  := "fire";
  tag[3]  := chngres;
  tag[4]  := ReadMilliSecondClock();

  SetObjProperty(caster, "spell_aura", tag);     // remember aura and tag caster for spellchecker
  SendSpellWaiter(caster, "spell_aura", CInt(dur * 1.5), tag[4], caster);

  // (in case caster logs off before spell ends)

  Set_Critical(1);
  resist:= CInt(GetObjProperty(caster, "resist_water"));   // get water resistance
  SetObjProperty(caster, "resist_water", resist - chngres);  // set new water resistance
  Set_Critical(0);

  PrintTextAbovePrivatePergon(caster, "Flammen lodern um Euch herum auf", "Flames blaze up around you", caster);

  SendStatus(caster);                                //Update Statuswindow

  detach();

  var flames := array;
  var flame  := struct;
  flame.+dir;
  flame.+flame;

  flame.dir   := 0;            // initialise 1st rotating flame
  flame.flame := CreateItemAtLocationPergon(caster.x+ConvertDirectionToLocX(flame.dir), 
                                           caster.y+ConvertDirectionToLocY(flame.dir), 
                                           caster.z, 0x19AB, 1,caster.realm);
  flame.flame.setProp("caster", caster.serial);
  flames[1]   := flame;

  flame.dir   := 4;             // initialise 2nd rotating flame
  flame.flame := CreateItemAtLocationPergon(caster.x+ConvertDirectionToLocX(flame.dir),
                                           caster.y+ConvertDirectionToLocY(flame.dir),
                                           caster.z, 0x19AB, 1,caster.realm);
  flame.flame.setProp("caster", caster.serial);
  flames[2]   := flame;

  While (caster and GetObjProperty(caster, "spell_aura")[2] == "fire" and !caster.dead and caster.connected)    // wait duration
    // get possible victims
    victims:= ListMobilesNearLocationEX(caster.x, caster.y, caster.z, 1, LISTEX_FLAG_NORMAL + LISTEX_FLAG_HIDDEN,caster.realm);
    If (victims.size())
      ForEach victim in victims
        If ((victim.serial != caster.serial) and (!victim.dead))              // preserve caster and ghosts
          If (victim.isa(POLCLASS_NPC))
            send_attack(victim, caster, 119);
          EndIf
  
          resist := 1 - CDbl(GetResistance(victim, "fire"));   // get victims fire resistance
          dmg    := CInt(basedmg * resist);                 // alter spell damage
          If (mindmg and mindmg > dmg)
            dmg := mindmg;
          ElseIf (maxdmg and maxdmg < dmg)
            dmg := maxdmg;
          EndIf
  
          ApplyRawDamagePergon(victim, dmg);                  // apply spell damage to victim
  
          If (RandomInt(100) <= power/3)                // check if victim gets pushed
            If (victim) // still alive?
              Pushback(caster, victim, range);
            EndIf
          EndIf
        EndIf
      EndForEach
    EndIf

    PlaySoundEffect(caster, SFX_1DE);                 // play aura sound
    For ani := 1 To 40                                // rotate flames
      If (!caster)
        Break;
      EndIf
      ForEach rotor in flames
        rotor.dir := (rotor.dir+1)%8;
        MoveObjectToLocation(rotor.flame,caster.x+ConvertDirectionToLocX(rotor.dir),
                                         caster.y+ConvertDirectionToLocY(rotor.dir),
                                         caster.z,caster.realm,
                                         MOVEOBJECT_FORCELOCATION+MOVEITEM_IGNOREMOVABLE);
      EndForEach
      SleepMS(50);
    EndFor

  EndWhile

  SleepMS(1);

  ForEach rotor in flames          // destroy aura
    DestroyItem(rotor.flame);
  EndForEach

  If (caster)
    PrintTextAbovePrivatePergon(caster, "Die Euch umgebenden Flammen verlöschen wieder",
                                        "The surrounding flames expire again", caster);
  EndIf

EndProgram

Function Pushback (who, whom, range)
  var dist := range - CInt(GetStrPergon(whom) / 30) + 1;      // calc how far char gets pushed

  If (dist <= 0)                               // no pushback
    return;
  EndIf
  
  dist := GetPossibleDistance(whom,dist,CInt(GetFacing(who.x,who.y,whom.x,whom.y)));
  MoveObjectToLocation(whom, whom.x + dist.x, whom.y + dist.y, whom.z, whom.realm, MOVEOBJECT_NORMAL);

EndFunction

Function GetPossibleDistance (who, range, dir)
  var dist := 0;
  var ret  := struct;
  ret.+x   := ConvertDirectionToLocX(dir);
  ret.+y   := ConvertDirectionToLocY(dir);

  While (CheckLosAt(who, who.x + ret.x*dist, who.y + ret.y*dist, who.z) and dist <= range)
    dist+= 1;
  EndWhile

  ret.x := (dist - 1) * ret.x;
  ret.y := (dist - 1) * ret.y;

  return ret;

EndFunction