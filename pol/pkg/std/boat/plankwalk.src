// Modification:
//    Turley 14.12.2004: -Tiere schaffen es auch ins Boot(werden angehoben/abgesenkt auf Plankenniveau
//               -Tiere benötigen keinen Schlüssel um an Bord zu kommen
//
//
// ToDo: -Warum eigentlich auf Schlüssel checken wenn die Planke eh draußen ist
//    wird beim ausfahren eh überprüft und wenn der Besitzer sie nicht selber zumacht selber schuld
//   -Benötigt man wirklich die set_criticals?

use os;
use storage;
use uo;
include ":doorsnew:common";
include "include/client";
include "include/objtype";

/*
 * the searchoffset matrix is for an east-facing plank.
 * these will have to be rotated for the other positions
 *   P is the plank, N is where you can't step (otherwise
 *    this teleportation stuff wouldn't be necessary)
 *
 *        13 12 11
 *        14  5  4
 *        15  6  2
 *        16  7  1 N P
 *        17  8  3
 *        18  9 10
 *        19 20 21
 *
 */

var searchoffset := {
   { -2,  0 },          //  1
   { -2, -1 },
   { -2, +1 },
   { -2, -2 },
   { -3, -2 },          //  5
   { -3, -1 },
   { -3,  0 },
   { -3, +1 },
   { -3, +2 },
   { -2, +2 },          // 10
   { -2, -3 },
   { -3, -3 },
   { -4, -3 },
   { -4, -2 },
   { -4, -1 },          // 15
   { -4,  0 },
   { -4, +1 },
   { -4, +2 },
   { -4, +3 },
   { -3, +3 },          // 20
   { -2, +3 },
   { -5,  0 },
   { -5, +2 },
   { -5, +3 },
   { -5, +4 },
   { -4, +4 },          // 20
   { -3, +4 },
   { -6,  0 },
   { -6, +3 },
   { -6, +4 },
   { -6, +5 },
   { -5, +5 },          // 20
   { -4, +5 }
};

program plankwalk(who, plank, lastx, lasty, lastz)
        //
        // see if someone is walking onto a locked plank from off the boat
        // if so, bounce them.
        //
        // it would be nice if core had a "canwalk" script capability, so
        // this code could just tell core to reject the walk in the first place.
        //
    if (
        !HasKeyFor(who, plank) &&
        // Tiere brauchen keinen Schlüssel
        !who.isa(POLCLASS_NPC)
    )
        if (plank.locked)
            var sh := GetStandingHeight(lastx, lasty, lastz,who.realm);
            if (!sh or !sh.multi || sh.multi.serial != plank.multi.serial)
                MoveObjectToLocation(who, lastx, lasty, lastz, who.realm, MOVEOBJECT_FORCELOCATION);
                return;
            endif
        endif
    endif

    if (ListMobilesNearLocation(plank.x, plank.y, plank.z, 0,plank.realm).size() > 1)
        MoveObjectToLocation(who, lastx, lasty, lastz, who.realm, MOVEOBJECT_FORCELOCATION);
        return;
    endif

    var xidx, yidx, xmul, ymul;

    case (plank.graphic)
        GID_PLANK_EXTENDED_FACING_WEST:
            if (! (who.facing in { DIR_W, DIR_NW, DIR_SW }))
              if (who.isa(POLCLASS_NPC))  // sonst schaffen es die Tiere nicht auf das Boot
                MoveObjectToLocation(who, who.x, who.y, plank.z, who.realm, MOVEOBJECT_FORCELOCATION);
              endif
              return;
            endif
            xidx := 1;
            yidx := 2;
            xmul := 1;
            ymul := 1;

        GID_PLANK_EXTENDED_FACING_EAST:
            if (! (who.facing in { DIR_E, DIR_NE, DIR_SE }))
              if (who.isa(POLCLASS_NPC))    // sonst schaffen es die Tiere nicht auf das Boot
                MoveObjectToLocation(who, who.x, who.y, plank.z, who.realm, MOVEOBJECT_FORCELOCATION);
              endif
              return;
            endif
            xidx := 1;
            yidx := 2;
            xmul := -1; // flip across x-axis
            ymul := 1;

        GID_PLANK_EXTENDED_FACING_NORTH:
            if (! (who.facing in { DIR_N, DIR_NE, DIR_NW }))
              if (who.isa(POLCLASS_NPC))  // siehe oben
                MoveObjectToLocation(who, who.x, who.y, plank.z, who.realm, MOVEOBJECT_FORCELOCATION);
              endif
              return;
            endif
            xidx := 2;
            yidx := 1;
            xmul := 1;
            ymul := +1;

        GID_PLANK_EXTENDED_FACING_SOUTH:
            if (! (who.facing in { DIR_S, DIR_SE, DIR_SW }))
              if (who.isa(POLCLASS_NPC))  // Siehe Oben
                MoveObjectToLocation(who, who.x, who.y, plank.z, who.realm, MOVEOBJECT_FORCELOCATION);
              endif
              return;
            endif
            xidx := 2;
            yidx := 1;
            xmul := 1;
            ymul := -1; // flip across y-axis

        default:
            print("unrecognized plank type");
            return;
    endcase

    // If the walker can stand one square past the plank, there's no need
    // to teleport.
    if (CanMove(who,
        CInt(searchoffset[1][xidx] * xmul / 2.0),
        CInt(searchoffset[1][yidx] * ymul / 2.0)))
        return;                     // doesn't need our help!
    endif


    foreach offset in searchoffset
        if (TryMove(who, offset[xidx] * xmul, offset[yidx] * ymul))
            return;
        endif
    endforeach

    // gah, can't get off the ship!
endprogram

function TryMove(who, dx, dy)
    var res := 0;

    var tryx := who.x + dx;
    var tryy := who.y + dy;
    var h := GetStandingHeight(tryx, tryy, who.z,who.realm);
    if (h && (not h.multi)) // CHECKME should check line of sight?
        MoveObjectToLocation(who, tryx, tryy, h.z, who.realm);
        res := 1;
    endif

    set_critical(0);
    return res;
endfunction

function CanMove(who, dx, dy)
    var tryx := who.x + dx;
    var tryy := who.y + dy;
    var h := GetStandingHeight(tryx, tryy, who.z,who.realm);
    if (h)
        return 1;
    else
        return 0;
    endif
endfunction
